/**
 * Sales migrations (MVP) â€” run inside the running API (no npm scripts).
 * Idempotent: safe to run multiple times.
 */
const { getPool } = require("../db");

async function runSalesMigrations() {
  const pool = getPool();
  const client = await pool.connect();

  const stmts = [
    `SET search_path TO public;`,

    // Tables
    `CREATE TABLE IF NOT EXISTS public.customers (
      id UUID PRIMARY KEY,
      email TEXT UNIQUE,
      full_name TEXT NOT NULL,
      phone TEXT,
      address TEXT,
      notes TEXT,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );`,

    `CREATE TABLE IF NOT EXISTS public.orders (
      id UUID PRIMARY KEY,
      order_no BIGINT GENERATED BY DEFAULT AS IDENTITY UNIQUE,
      customer_id UUID NOT NULL REFERENCES public.customers(id) ON DELETE RESTRICT,

      status TEXT NOT NULL DEFAULT 'DELIVERED'
        CHECK (status IN ('PENDING_CONFIRMATION','CONFIRMED','PREPARING','READY','DELIVERED','CANCELLED')),

      payment_status TEXT NOT NULL DEFAULT 'PAID'
        CHECK (payment_status IN ('PENDING','PAID','FAILED','REFUNDED')),

      payment_method TEXT NOT NULL DEFAULT 'CASH'
        CHECK (payment_method IN ('TRANSFER','CASH','ONLINE')),

      delivery_method TEXT NOT NULL DEFAULT 'PICKUP'
        CHECK (delivery_method IN ('PICKUP','DELIVERY')),

      subtotal_clp INT NOT NULL DEFAULT 0,
      delivery_fee_clp INT NOT NULL DEFAULT 0,
      total_clp INT NOT NULL DEFAULT 0,

      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );`,

    `CREATE TABLE IF NOT EXISTS public.order_items (
      id UUID PRIMARY KEY,
      order_id UUID NOT NULL REFERENCES public.orders(id) ON DELETE CASCADE,
      product_id UUID NOT NULL REFERENCES public.products(id) ON DELETE RESTRICT,

      product_name_snapshot TEXT NOT NULL,
      unit_price_clp INT NOT NULL,
      qty INT NOT NULL CHECK (qty > 0),
      line_total_clp INT NOT NULL,

      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );`,

    // Fix columns (in case table exists without them)
    `ALTER TABLE IF EXISTS public.customers ADD COLUMN IF NOT EXISTS address TEXT;`,
    `ALTER TABLE IF EXISTS public.customers ADD COLUMN IF NOT EXISTS notes TEXT;`,
    `ALTER TABLE IF EXISTS public.customers ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ NOT NULL DEFAULT NOW();`,
    `ALTER TABLE IF EXISTS public.customers ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW();`,

    `ALTER TABLE IF EXISTS public.orders ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ NOT NULL DEFAULT NOW();`,
    `ALTER TABLE IF EXISTS public.orders ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW();`,

    `ALTER TABLE IF EXISTS public.order_items ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ NOT NULL DEFAULT NOW();`,

    // Indexes
    `CREATE INDEX IF NOT EXISTS idx_orders_created_at ON public.orders(created_at);`,
    `CREATE INDEX IF NOT EXISTS idx_orders_customer ON public.orders(customer_id);`,
    `CREATE INDEX IF NOT EXISTS idx_orders_status ON public.orders(status);`,
    `CREATE INDEX IF NOT EXISTS idx_order_items_order ON public.order_items(order_id);`,
    `CREATE INDEX IF NOT EXISTS idx_order_items_product ON public.order_items(product_id);`,

    // updated_at triggers
    `CREATE OR REPLACE FUNCTION public.set_updated_at()
     RETURNS trigger AS $fn$
     BEGIN
       NEW.updated_at = NOW();
       RETURN NEW;
     END;
     $fn$ LANGUAGE plpgsql;`,

    `DROP TRIGGER IF EXISTS trg_customers_updated_at ON public.customers;`,
    `CREATE TRIGGER trg_customers_updated_at
     BEFORE UPDATE ON public.customers
     FOR EACH ROW EXECUTE PROCEDURE public.set_updated_at();`,


    `DROP TRIGGER IF EXISTS trg_orders_updated_at ON public.orders;`,
    `CREATE TRIGGER trg_orders_updated_at
     BEFORE UPDATE ON public.orders
     FOR EACH ROW EXECUTE PROCEDURE public.set_updated_at();`,
  ];

  try {
    await client.query("BEGIN");
    for (const s of stmts) {
      await client.query(s);
    }
    await client.query("COMMIT");
  } catch (e) {
    try { await client.query("ROLLBACK"); } catch {}
    throw e;
  } finally {
    client.release();
  }
}

module.exports = { runSalesMigrations };
